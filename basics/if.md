[变量绑定][vb]

[vb]: variable_binding.md

#If
- - -

Rust的if不是特别复杂，你会发现相比传统语言它更像动态语言中的if多一些，让我们来学习他，让你了解它的细微差别

if 是更广泛概念“分支”的一种特殊形式，它的名字来源于树的分支，基于一个选择判断带多个执行路径的决策点.

下面是一个if例子，这有一个选择判断(if x==5)，有两个执行路径

    let x = 5;

    if x == 5 {
        println!("x is five!");
    }

如果我们改变x为其他值，这个行就不会打印，更详细的说，如果if后面的表达式执行后是true，紧挨着的语句块就执行，如果是false，就不执行

如果你想在执行结果是false情况下打印别的，就是用**else**

    let x = 5;

    if x == 5 {
        println!("x is five!");
    } else {
        println!("x is not five :(");
    }
    
上面是完整形式，或者你也可以像下面这样:
    
    let x = 5;

    let y = if x == 5 {
        10
    } else {
        15
    }; // y: i32
    
或者这样(或许应该)写:
    
    let x = 5;

    let y = if x == 5 { 10 } else { 15 }; // y: i32
    
Rust是一个基于表达式的语言，而分号的作用也不同于其它“大括号-分号”形式系的语言，这两个东西是相关联的

#表达式 VS 语句
- - -

Rust主要基于表达式的语句，在Rust中只有两种语句，其他就是表达式，

这有什么不同么，表达式返回值，语句不返回值，在许多语言中，if是一个语句，因为**let x= if**没有意义，但是
在Rust中，if是一个表达式，意味着他将返回一个值，我们能够使用这个值来初始化绑定。

说起这个,绑定是Rust两种语句中的一种，正式名称叫做*声明语句*，目前为止，let是我们看到的唯一的一种声明语句，让我们来更深入了解他。

在在一些语言中，变量绑定可以被写成表达式，不仅仅是语句，类似ruby：

    x=y=5
    
然而在Rust中，使用let来引入一个绑定而不是一个表达式，下面的代码在编译时会产生错误，
    
    let x = (let y = 5); // expected identifier, found keyword `let`
   
编译告诉我们他希望看到一个表达式开始，let只能用来作为语句开始，而不是一个表达式。

注意，分配给一个已经绑定的变量(例如y=5)仍然是一个表达式，尽管他的返回值没什么用，不像C，一个赋值计算的结果就是分配的值,(例如前面的5就是返回结果)，在rust中，一个赋值分配的返回结果是单元类型-**()**,过后我们会讲。

Rust中第二种语句就是表达式语句，它的作用就是将表达式变成语句，实际上，Rust的语法希望语句接着其他语句，这就是说，你使用分号分隔表达式，意味着，Rust看起来像大多数其他语言一样需要在每行结尾使用分号，你也会看到每行Rust代骂结尾都有一个分号。

那么有没有例外呢，看下面的代码：

    let x = 5;

    let y: i32 = if x == 5 { 10 } else { 15 };
    
注意，我已经给y加上了类型声明，显示的指定我想让y是一个整数，

下面的就不一样，并且不会通过编译，


    let x = 5;

    let y: i32 = if x == 5 { 10; } else { 15; };
    
注意10和15后面的分号，Rust 将提示你下面的错误

    
    error: mismatched types: expected `i32`, found `()` (expected i32, found ())
    
我们希望得到一个整数，但是却得到了()，()读作*单元*，在Rust 类型系统中是一个特殊的类型，在Rust中()对于i32类型不是一个有效的值，只是对()类型有效的值，不是很有用，记住。我们说过语句不返回值？这就是单元的用途，分号使表达式变成了语句扔掉了它原来的返回值，然后返回了单元

有一种情况。就是你不会看到一行Rust代码以分号结尾，想知道这个。我们来学习下面内容:函数

[函数][fun]

[fun]: fun.md














