#指针
 - - -
Rust的指针是它的独特和引人注目的特性之一。对于Rust新人它也是令人迷惑的知识点，即使是来自其他支持指针的语言的使用者，例如c++,他也是令人迷惑的，本章节，将帮助你理解这个知识点

对非引用指针持怀疑态度:使用他们要深思熟虑，不仅仅是为了取悦编译器。本节中，当他们在使用时，每个指针类型都会给予解释，除非你处在特殊情况中，否则使用默认引用。

你或许对[参考手册]有兴趣,快速的对类型,命名，指针用途有一个快速预览

[参考手册]: http://doc.rust-lang.org/1.0.0-beta/book/pointers.html#cheat-sheet


#介绍
- - - 
如果你对于指针没有什么概念，这有一个简短介绍，在系统级编程语言中，指针是一个基本的概念，理解他们很重要

#指针基础
 - - -
当你创建一个新的变量绑定时，一个变量名对应一个值，存储在栈上的一个特殊地方(如果你不熟悉堆和栈请看[这里]),

[这里]: http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap

像这样:
    let x = 5;
    let y = 8;
    
| 地址 | 值 |
|------|----|
| 0xd3e030 | 5 |
| 0xd3e028 | 8 |

我们编造了内存地址。他们仅仅是简单的数值。重点是x。我们变量的名字。对应的内存地址是*0xd3e030*,内存存储的值是5，
当我们使用x,我们得到对应的值，因此，x就是5


让我们引入指针，在一些语言中，仅仅有一种指针类型，但是在rust中，我们有许多，在这个例子中，我们使用*引用*,最简单的一种指针类型
    let x = 5;
    let y = 8;
    let z = &y;

| 地址 | 值 |
|------|----|
| 0xd3e030 | 5 |
| 0xd3e028 | 8 |
| 0xd3e020 | 0xd3e028 |

发现不同了么，不是包含一个值，指针的值是内存中一块地址的值，在这个例子中是y的地址，x和y是i32类型那个，但是z是&i32类型，我们使用{:p}输出地址

    let x = 5;
    let y = 8;
    let z = &y;
                                
     println!("{:p}", z);
       
将打印我们虚构的内存地址: **0xd3e028**


因为i32与&i32是不同类型，我们不能将它们相加


    let x = 5;
    let y = 8;
    let z = &y;

    println!("{}", x + z);

我们将得到一个错误
        hello.rs:6:24: 6:25 error: mismatched types: expected `_`, found `&_` (expected integral variable, found &-ptr)
    hello.rs:6     println!("{}", x + z);
       
我们可以使用*操作符反向引用指针。 *操作符意思是访问存储在指针上的地址的值。下面代码没问题

    let x = 5;
    let y = 8;
    let z = &y;

    println!("{}", x + *z);
    
它会打印13。

OK。这就是指针:指向某个内存地址。不是其他什么，现在我们知道指针是什么。让我们了解如何使用它

#指针使用

- - - 
Rust的指针十分有用，但是使用方式不同于其他语言中的指针，本节稍后谈乱指针的最佳使用方式，在这我们谈论一下其他语言中的使用

在C语言中，字符串是一个指向一个以空字符结尾的字符序列，使用字符串的唯一方式是熟悉指针

指针十分有用。特别是指向不在栈内存上的内存地址。例如，我们前面使用栈变量的例子，我们可以给他们命名，但是如果是在对内存上分配。我们没有命名的可能性，在C语言中，malloc用于分配堆内存，并且返回一个指针。

作为前面两点常规的变体，在任何时候你有一个可以改变大小的结构，就需要一个指针，你不能在编译的时候指定分配多少内存，所以，你需要一个指针指向被分配内存的地址，在运行的时候处理它。

指针在语言中很有用，基本上，计算机语言可以做两种选择，(下面的语法是编造的，不是rust的)

    func foo(x) {
        x = 5
    }

    func main() {
        i = 1
        foo(i)
        // what is the value of i here?
    }

 在传递值得语言中，foo将得到一份i的拷贝，所以原始版本的i没有改变，这时i让然是1， 在传递引用的语言中，foo将得到i的引用，可以改变i的值，这时候，i将会是5
 
 用指针怎么处理这个呢，因为指针可以指向一个内存地址
 
     func foo(&i32 x) {
        *x = 5
     }

    func main() {
        i = 1
        foo(&i)
        // what is the value of i here?
    }

即使在传递值的语言中，i将会是5，因为x是一个指针，我们传递了一个拷贝给foo，但是拷贝指向了一个内存地址。我们分配值，原始值会改变，这个模式叫做**通过值传递引用**,微妙！


#指针的常见问题

- - -




